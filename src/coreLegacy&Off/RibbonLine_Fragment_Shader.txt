



fragmentShader: `
        uniform vec3 uColor;
        uniform vec3 uColorEnd;
        uniform float uTime;
        uniform int uFadeStyle;
        uniform int uRenderMode;
        uniform float uOpacity;
        uniform float uColorMix;
        uniform float uTransitionSize;
        
        varying vec2 vUv;
        const float PI = 3.14159265359;

        void main() {
          vec4 finalColor;
          if (uRenderMode == 0) {
            float distanceToCenter = abs(vUv.y - 0.5) * 2.0;
            float strength = 1.0 - distanceToCenter;
            float glow = pow(strength, 2.5);
            float pulse = (sin(uTime * 5.0) + 1.0) / 2.0;
            pulse = pulse * 0.4 + 0.6;
            
            float tailFade = 1.0;
            if (uFadeStyle == 1) { tailFade = vUv.x; }
            else if (uFadeStyle == 2) { tailFade = sin(vUv.x * PI); }
            else if (uFadeStyle == 3) { tailFade = 1.0 - vUv.x; }

            float finalAlpha = glow * tailFade * pulse * uOpacity;
            finalColor = vec4(uColor, finalAlpha);
          } else {
            float mixFactor = smoothstep(uColorMix - uTransitionSize, uColorMix, vUv.x);
            vec3 gradientColor = mix(uColor, uColorEnd, mixFactor);
            
            float tailFade = 1.0;
            if (uFadeStyle == 1) { tailFade = vUv.x; }
            else if (uFadeStyle == 2) { tailFade = sin(vUv.x * PI); }
            else if (uFadeStyle == 3) { tailFade = 1.0 - vUv.x; }

            finalColor = vec4(gradientColor, uOpacity * tailFade);
          }
          gl_FragColor = finalColor;
        }
      `,